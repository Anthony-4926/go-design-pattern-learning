# 代理模式

> 个人觉得“代理模式”这个词并不合理。正常情况下理解“代理”一词应该是，自己啥都不用管，所有工作都有代理负责。但是，“代理模式”中的“代理”不是这个样子滴。
>
> 举个例子：在淘宝上找个代理，帮我申请专利。这时候代理会提供两种服务：
>
> 1. 我只需要出钱，代理便帮我完成我的需求，专利技术、文档、向专利局申请等过程都不用我管。
> 2. 我完成核心的内容，比如专利技术，撰写专利文档；代理只帮我解决其他乱七八糟的琐事。
>
> “代理模式”中的“代理”是第二种情况。

代理模式的应用场景下有**主题**和**行为**两个关键要素，行为是该主题下的一个动作。代理只能代理主题，不能代理行为。

# 角色和职责

| **角色**   | **职责**                                             |
| ---------- | ---------------------------------------------------- |
| 抽象的主题 | 真实主题与代理主题的共同接口。                       |
| 具体主题   | 执行真正需求动作                                     |
| 代理主题   | 除了调用具体主题的动作外，还可以处理一些其他周边事情 |

# 适用范围

- 1、业务系统的非功能性需求开发

一些非功能性的业务需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。

- 2、代理模式在RPC中的应用

RPC框架也可以看成是一种代理模式。

GoF的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端使用RPC服务就像使用本地函数一样，RPC服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。

- 3、代理模式在缓存中的应用

对于一些接口的开发，有时候对于一个功能，我们会提供两种接口，一种支持缓存，一种不支持缓存，对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。

简单的做法就是接口写两个，一个支持缓存的一个不支持缓存，但是这样我们的代码就有些臃肿了。

可以使用代理模式中的动态代理。举个栗子：

如果是基于Spring框架来开发的话，那就可以在AOP切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在AOP切面中拦截请求，如果请求中带有支持缓存的字段（比如http://…?..&cached=true），我们便从缓存（内存缓存或者Redis缓存等）中获取数据直接返回。

# 类图

<img src="http://imgbed4926.oss-cn-hangzhou.aliyuncs.com/img/image-20221219210849577.png" alt="image-20221219210849577" height="350dp" />

# 代码实现

```Go
package main

import "fmt"

// ----------------------抽象的主题--------------------
type ApplyPatent interface {
   writeDoc()
}

// ----------------------具体的主题--------------------
type ApplyUtilityModelPatent struct {
}

func (ApplyUtilityModelPatent) writeDoc() {
   fmt.Println("撰写实用新型专利的创新文档")
}

type ApplyInventionPatent struct {
}

func (ApplyInventionPatent) writeDoc() {
   fmt.Println("撰写发明专利的创新文档")
}

// ----------------------具体的主题--------------------
type Proxy struct {
   Patent ApplyPatent
}

func (p Proxy) writeDoc() {
   fmt.Println("注册账号")

   // 调用
   p.Patent.writeDoc()

   fmt.Println("递交申请")
}

func main() {
   var proxy Proxy
   proxy = Proxy{
      Patent: ApplyInventionPatent{},
   }
   proxy.writeDoc()

   proxy = Proxy{
      Patent: ApplyUtilityModelPatent{},
   }
   proxy.writeDoc()
}
注册账号
撰写发明专利的创新文档
递交申请
注册账号
撰写实用新型专利的创新文档
递交申请
```

# **优点**

1、代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；

2、代理对象可以扩展目标对象的功能；

3、代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性；

# **缺点**

1、代理模式会造成系统设计中类的数量增加；

2、在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；

3、增加了系统的复杂度；